# EEC 172 Final - Golf Simulator

Sean Weber - Ryan Nguyen
## Project Description
Our motivation for this project was a combination of our enjoyment of minigolf as well as client-server models in software engineering. While discussing potential ideas for our project at the beginning, we remembered the requirement for at least 2 sensors, and we realized that most of our ideas did not work within these requirements. Then we both considered a minigolf style game, and as we both continued to consider the idea, the more we enjoyed it and continued to develop the idea to something we could act upon. Furthermore, our enjoyment of server-client models also added to the project, where we decided to make it so one board was the client that played the game but all the actual data was handled by the server.
The golf minigame consists of a client-run board which has access to basic tools such as a help screen as well as the gameplay of the minigolf courses. The client contains a menu screen the user can traverse. Selecting maps and looking at each map causes the client to send requests to the server using the REST API on AWS. The server will then get these AWS requests by actively sending GET requests to the AWS shadow, and then handles the requests, either updating map lists, identifying specific map data, updating leaderboards, or saving leaderboards when the client exits the program. The client receives these updates to play different maps, and uses the accelerometer as well as the tv remote to update the angle of the swing, and then enters the fire mode to swing the club, where the accelerometer uses the change in x, y, and z values to identify the power of the swing. Upon completion of the courses, the client is prompted to input their name and then sends their score to the server, which as stated updates leaderboards if their score was good enough.
## Reproducibility
 In hardware, the client has the most significant connections to the devices used in the final project. On the other hand, the server has no devices directly connected to it, only using AWS to communicate with the client board. For the IR Receiver, the most notable method to decode the receiver values that are sent to the GPIO is by using a timer interrupt handler along with interrupts for the GPIO. When these values are detected and the interrupt is called, the code must consider the timer's current value to identify how long the pin was high or low. Using this, along with the coding scheme of the tv remote, will be able to identify which codes are what. Note that these codes require multiple interrupts on the GPIO to be called, as the codes contain multiple highs and lows to create the respective codes. When these codes are deciphered, the client then uses the current state of the code to identify what to do with these codes, either enter a name or traverse the menu screens or switch the state in the game mode. For the OLED, connect the respective wires to send data via SPI allows for the code to properly create a UI for playing the game and traversing the menu screens. Finally, for the accelerometer, connecting via I2C is how the code communicates and reads the accelerometer data. This data is read and evaluated only in the game mode when determining the angle to shoot the golf ball when swinging the club. Again, this depends on the state of the program. Finally, UART also must be established so the program can inform the user of the status of the program and what is being sent and received via AWS's REST API. For the communication via AWS, use the REST API formatting for GET and POST http requests in order to update the shadow, and the updates should provide the required request fields and other data needed by the server, while the server should send back the respective information or make the proper updates. For the coding side of things, the server consists of GET requests followed by parsing the responses and modifying values and sending POST requests back, as well as data containing the map information and a variable to store the leaderboards. For the client code, use state variables that be changed based on remote code sends, whether the ball is moving, recordings from the accelerometers, and finally using AWS POST requests in order to get proper information when entering new states. The states consist of menu and help screens, a map list, a specific map info, a game mode with it's respective game states, and finally a leaderboard state to record scores to a name. For hardware implementation, we kept the wiring the same as lab 3, where we hook up the OLED screen and the IR sensor the exact same way as those labs. We only disconnected UART1 since we did not need board to board communication via UART and then went back to Lab 2 to set up the I2C connection. We set the SCL to pin 3 and SDA to pin 4, respectively. Our accelerometer from the golf club had 4 pins, VCC, GND, SCL, SDA. The brown wire on the bottom was SCL and the orange wire was SDA. Then we hooked up the black wire to GND and the board's VCC output to the accelerometer. Then after some setup in the client code, the accelerometer started reading values.
## Design
For the client code, the client begins in the menu screen. From here, the client uses the tv remote to pick between the options of Maps, Help, and Exit using 2 as up, 8 as down, and 5 as select. Help sends the client to the Help Screens, which are itself a list of screens that have important button bindings to explain how to traverse the map, with the LAST button returning to the main menu screen. Selecting Exit sends an exit request (request = 4), which informs the server to save the leaderboards and exit as well. Selecting Maps sends a request to the server (request = 1) to get the map list. This puts the client into the map list where they can go select between maps, where selecting NEXT and PREV traverses between the maps, and SELECT chooses one. As before, LAST returns to the main menu. Selecting a map sends another request to the server (request = 2) where the server provides the info for the map selected by the client. This puts the client into the Map info screen, where they can return by selecting BACK or Play by selecting Play. By pressing play, the client enters the game state, where the client uses LAST, MUTE, and the 2 buttons to set and swing the golf club. LAST sets the client into an empty state where they can only see the board, mostly used as an intermediary between the angle selection and swinging mode. Pressing 2 sets the client into the angle mode, which uses the accelerometer on the club to set the angle. Pressing MUTE will put the golf club in firing mode. This consists of setting the current accelerometer reading with a tolerance as the ready zone. Leaving this zone will record the acceleration changes to determine the power of the swing. When this power is determined, the ball is hit with that power in that direction. when the ball gets into the hole or when they have exceeded all the shots available, they are then put into a name entering screen. Using the Lab 3 method of using the tv remote to make a text maker allows the user to write a 4 letter name to send over to the server to update the leaderboard. After this, they are put back into the map list state. For the server code, this mainly consists of GET requests to handle the updates and sending info to the client. The server first sends a GET request, and evaluates if the request is 0 or not. If it is, continue and send another GET request. If it isn't 0, handle the request. For request of type 1, the server will send via AWS a list of the maps. For a request of type 2, it will send the specific map specified in the request. For a request of type 3, it checks the leaderboard to determine whether the score sent in the request needs to be added to the leaderboard, and save it to the leaderboard if so. If the request is of type 4, this means the client has exited, and so the server will save the current leaderboard in AWS, and then leave as well. Furthermore, it sets the request to type 5. Requests of type 5 will pull the leaderboard from AWS and restore the data, so that when the server starts back up from turning off it will take the most up to date data from AWS.
## Maps
### Map 1
![map1](./IMG_6365.png)
### Map 2
![map1](./IMG_6366.png)
### Map 3
![map1](./IMG_6368.png)
## Demo Videos
### Start Sequence and General Layout
[![Watch on YouTube](https://img.youtube.com/vi/dNdLlvfLy9k/0.jpg)](https://youtube.com/shorts/dNdLlvfLy9k)

### Gameplay
[![Watch on YouTube](https://img.youtube.com/vi/Q7B1dx4AepA/0.jpg)](https://youtube.com/shorts/Q7B1dx4AepA)




